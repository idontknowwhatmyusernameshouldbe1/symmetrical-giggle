<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cube in a Random Maze</title>
  <style>
    :root { --bg: #0e0f13; --fg:#e7ebf3; --accent:#6ee7ff; --accent2:#9bffa3; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    .app { display:grid; grid-template-rows:auto 1fr auto; height:100%; }
    header { padding:10px 14px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header h1 { margin:0; font-size:16px; font-weight:600; letter-spacing:.3px; opacity:.9 }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, select, input[type="number"] { background:#171923; color:var(--fg); border:1px solid #25293a; border-radius:10px; padding:8px 10px; font-size:14px; }
    button:hover { border-color:#2f3550 }
    button.primary { border-color:#2a3648; box-shadow: inset 0 0 0 1px #2a3648; }
    .wrap { position:relative; height:100%; }
    canvas { width:100%; height:100%; display:block; }
    .hud { position:absolute; left:10px; bottom:10px; background:rgba(15,17,23,.6); backdrop-filter: blur(4px); border:1px solid #25293a; border-radius:12px; padding:10px 12px; font-size:13px; line-height:1.45; max-width:min(90vw, 520px); }
    .hud kbd { background:#0e1017; border:1px solid #2b3045; padding:1px 5px; border-radius:6px; font-size:12px }
    .toast { position:absolute; right:10px; top:10px; padding:8px 12px; border-radius:10px; background:#15202b; border:1px solid #253247; font-size:13px }
    .dpad { position:absolute; right:12px; bottom:12px; display:grid; grid-template-columns:48px 48px 48px; grid-template-rows:48px 48px 48px; gap:6px; opacity:.9 }
    .dpad button { width:48px; height:48px; border-radius:12px; user-select:none; touch-action:manipulation; }
    .dpad button[disabled] { opacity:.35 }
    footer { padding:8px 14px; font-size:12px; opacity:.8; display:flex; gap:6px; align-items:center; }
    .goalBlink { filter: drop-shadow(0 0 8px var(--accent)); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Cube in a Random Maze</h1>
      <div class="controls">
        <label>Size:
          <input id="size" type="number" min="9" max="201" step="2" value="51" title="Odd numbers only (cells across & down)" />
        </label>
        <button id="new" class="primary" title="Generate a brand new maze (R)">New Maze</button>
        <button id="reset" title="Reset cube to start (Backspace)">Reset</button>
        <button id="solve" title="Show shortest path (S)">Show Path</button>
      </div>
    </header>

    <div class="wrap">
      <canvas id="c"></canvas>
      <div class="hud" id="hud"></div>
      <div class="toast" id="toast" style="display:none"></div>
      <div class="dpad" id="dpad" aria-hidden="true">
        <span></span><button data-dy="-1">▲</button><span></span>
        <button data-dx="-1">◀</button><span></span><button data-dx="1">▶</button>
        <span></span><button data-dy="1">▼</button><span></span>
      </div>
    </div>

    <footer>
      Controls: <kbd>WASD</kbd> or <kbd>Arrow Keys</kbd>, <kbd>R</kbd> new maze, <kbd>S</kbd> show path, <kbd>Backspace</kbd> reset. Reach the glowing square!
    </footer>
  </div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const toastEl = document.getElementById('toast');
  const sizeInput = document.getElementById('size');
  const btnNew = document.getElementById('new');
  const btnReset = document.getElementById('reset');
  const btnSolve = document.getElementById('solve');
  const dpad = document.getElementById('dpad');

  const state = {
    N: 51, // grid size (must be odd)
    grid: [], // 0 wall, 1 passage
    start: {x:1, y:1},
    goal: null,
    pos: {x:1, y:1},
    anim: { from:{x:1,y:1}, to:{x:1,y:1}, t:1 },
    path: null,
  };

  function odd(n){ return (n|0) % 2 === 1 ? (n|0) : (n|0)+1; }

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', resize);

  function showToast(msg, ms=1400){
    toastEl.textContent = msg;
    toastEl.style.display = 'block';
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toastEl.style.display = 'none', ms);
  }

  // Maze generation: randomized DFS (recursive backtracker, iterative)
  function genMaze(N){
    N = odd(N);
    const grid = Array.from({length:N}, (_,y)=> Array.from({length:N},(_,x)=> 0));
    const stack = [];
    const start = {x:1, y:1};
    grid[start.y][start.x] = 1;
    stack.push(start);

    const dirs = [ [0,-1], [1,0], [0,1], [-1,0] ];
    while(stack.length){
      const cur = stack[stack.length-1];
      // find neighbors two steps away that are walls
      const candidates = [];
      for(const [dx,dy] of dirs){
        const nx = cur.x + dx*2;
        const ny = cur.y + dy*2;
        if(nx>0 && ny>0 && nx<N-1 && ny<N-1 && grid[ny][nx]===0){
          candidates.push({nx,ny,wx:cur.x+dx, wy:cur.y+dy});
        }
      }
      if(candidates.length){
        const pick = candidates[Math.floor(Math.random()*candidates.length)];
        grid[pick.wy][pick.wx] = 1; // open wall in between
        grid[pick.ny][pick.nx] = 1; // open target cell
        stack.push({x:pick.nx, y:pick.ny});
      } else {
        stack.pop();
      }
    }

    // place goal at farthest passage from start using BFS
    const far = farthestCell(grid, start);
    const goal = far.cell;

    return {grid, start, goal};
  }

  function neighbors(grid, x,y){
    const res=[]; const N=grid.length;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(nx>=0 && ny>=0 && nx<N && ny<N && grid[ny][nx]===1) res.push({x:nx,y:ny});
    }
    return res;
  }

  function farthestCell(grid, start){
    const N=grid.length; const dist=Array.from({length:N},()=>Array(N).fill(Infinity));
    const q=[start]; dist[start.y][start.x]=0; let cell=start, d=0;
    while(q.length){
      const cur=q.shift();
      const nd=dist[cur.y][cur.x]+1;
      for(const nb of neighbors(grid, cur.x, cur.y)){
        if(dist[nb.y][nb.x] > nd){ dist[nb.y][nb.x]=nd; q.push(nb); if(nd>d){ d=nd; cell=nb; } }
      }
    }
    return {cell, dist};
  }

  function shortestPath(grid, start, goal){
    const N=grid.length; const dist=Array.from({length:N},()=>Array(N).fill(Infinity));
    const prev=Array.from({length:N},()=>Array(N).fill(null));
    const q=[start]; dist[start.y][start.x]=0;
    while(q.length){
      const cur=q.shift();
      if(cur.x===goal.x && cur.y===goal.y) break;
      const nd=dist[cur.y][cur.x]+1;
      for(const nb of neighbors(grid, cur.x, cur.y)){
        if(dist[nb.y][nb.x] > nd){ dist[nb.y][nb.x]=nd; prev[nb.y][nb.x]=cur; q.push(nb); }
      }
    }
    const path=[]; let cur=goal; if(prev[cur.y][cur.x]|| (cur.x===start.x && cur.y===start.y)){
      while(cur){ path.push(cur); cur=prev[cur.y][cur.x]; }
      path.reverse();
    }
    return path;
  }

  function newMaze(N){
    const {grid, start, goal} = genMaze(N);
    state.N = grid.length;
    state.grid = grid;
    state.start = start;
    state.goal = goal;
    state.pos = {x:start.x, y:start.y};
    state.anim = {from:{...state.pos}, to:{...state.pos}, t:1};
    state.path = null;
    updateHUD();
    draw();
  }

  function updateHUD(){
    hud.innerHTML = `Size: <b>${state.N}x${state.N}</b> cells<br/>`+
      `Position: <b>(${state.pos.x}, ${state.pos.y})</b><br/>`+
      `Goal: <b>(${state.goal.x}, ${state.goal.y})</b><br/>`+
      `Keys: WASD / Arrows, R = new, S = path, Backspace = reset`;
  }

  function tryMove(dx,dy){
    const nx = state.pos.x + dx;
    const ny = state.pos.y + dy;
    if(state.grid[ny]?.[nx] !== 1) { return; }
    state.anim = { from:{...state.pos}, to:{x:nx,y:ny}, t:0 };
    state.pos = {x:nx, y:ny};
    if(nx===state.goal.x && ny===state.goal.y){ showToast('Goal! New maze with R'); }
    draw();
  }

  function keyHandler(e){
    const k=e.key.toLowerCase();
    if(["arrowup","w"].includes(k)){ e.preventDefault(); tryMove(0,-1); }
    else if(["arrowdown","s"].includes(k)){ e.preventDefault(); tryMove(0,1); }
    else if(["arrowleft","a"].includes(k)){ e.preventDefault(); tryMove(-1,0); }
    else if(["arrowright","d"].includes(k)){ e.preventDefault(); tryMove(1,0); }
    else if(k==='r'){ newMaze(sizeValue()); }
    else if(k==='s'){ state.path = shortestPath(state.grid, state.pos, state.goal); draw(); }
    else if(k==='backspace'){ e.preventDefault(); state.pos={...state.start}; state.anim={from:{...state.pos}, to:{...state.pos}, t:1}; state.path=null; draw(); }
  }
  window.addEventListener('keydown', keyHandler, {passive:false});

  // D-Pad for touch
  dpad.addEventListener('click', (e)=>{
    const dx = Number(e.target.getAttribute('data-dx')||0);
    const dy = Number(e.target.getAttribute('data-dy')||0);
    if(dx||dy) tryMove(dx,dy);
  });

  function sizeValue(){
    let v = parseInt(sizeInput.value || '51', 10);
    if (isNaN(v)) v = 51;
    v = Math.max(9, Math.min(201, v));
    if(v % 2 === 0) v += 1; // force odd
    sizeInput.value = v;
    return v;
  }

  btnNew.addEventListener('click', ()=> newMaze(sizeValue()));
  btnReset.addEventListener('click', ()=> { state.pos={...state.start}; state.anim={from:{...state.pos}, to:{...state.pos}, t:1}; state.path=null; draw(); });
  btnSolve.addEventListener('click', ()=> { state.path = shortestPath(state.grid, state.pos, state.goal); draw(); });

  // Render
  function draw(){
    const {width, height} = canvas.getBoundingClientRect();
    const N = state.N;
    const cell = Math.floor(Math.min(width, height) / N);
    const padX = Math.floor((width - cell*N)/2);
    const padY = Math.floor((height - cell*N)/2);

    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw background grid (walls/passages)
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const px = padX + x*cell;
        const py = padY + y*cell;
        if(state.grid[y][x]===1){
          // passage
          ctx.fillStyle = '#121520';
          ctx.fillRect(px, py, cell, cell);
        } else {
          // wall
          ctx.fillStyle = '#0a0c12';
          ctx.fillRect(px, py, cell, cell);
        }
      }
    }

    // path (optional)
    if(state.path && state.path.length){
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#243b55';
      for(const p of state.path){
        const px = padX + p.x*cell + 3;
        const py = padY + p.y*cell + 3;
        ctx.fillRect(px, py, Math.max(1,cell-6), Math.max(1,cell-6));
      }
      ctx.globalAlpha = 1;
    }

    // goal
    {
      const gx = padX + state.goal.x*cell;
      const gy = padY + state.goal.y*cell;
      const m = Math.max(2, Math.floor(cell*0.2));
      ctx.save();
      ctx.fillStyle = '#6ee7ff';
      ctx.shadowColor = '#6ee7ff';
      ctx.shadowBlur = 12;
      ctx.fillRect(gx+m, gy+m, cell-2*m, cell-2*m);
      ctx.restore();
    }

    // animate cube
    const speed = 8; // cells per second visually
    if(state.anim.t < 1){
      state.anim.t = Math.min(1, state.anim.t + (speed/60));
    }
    const t = ease(state.anim.t);
    const cx = state.anim.from.x + (state.anim.to.x - state.anim.from.x)*t;
    const cy = state.anim.from.y + (state.anim.to.y - state.anim.from.y)*t;

    const px = padX + cx*cell;
    const py = padY + cy*cell;

    // cube
    const m = Math.max(2, Math.floor(cell*0.2));
    ctx.save();
    ctx.fillStyle = '#9bffa3';
    ctx.strokeStyle = '#2f7840';
    ctx.lineWidth = Math.max(1, cell*0.05);
    ctx.shadowColor = '#9bffa3';
    ctx.shadowBlur = 6;
    ctx.fillRect(px+m, py+m, cell-2*m, cell-2*m);
    ctx.strokeRect(px+m, py+m, cell-2*m, cell-2*m);
    ctx.restore();

    requestAnimationFrame(()=>{
      if(state.anim.t < 1) draw();
    });
  }

  function ease(t){ // smoothstep-ish
    return t<.5 ? 2*t*t : -1+(4-2*t)*t;
  }

  // init
  sizeInput.addEventListener('change', ()=> newMaze(sizeValue()));
  newMaze(sizeValue());
  resize();

  // mobile: show dpad if viewport small
  function updateDpad(){
    const small = window.matchMedia('(max-width: 720px)').matches;
    dpad.style.display = small ? 'grid' : 'none';
  }
  updateDpad();
  window.addEventListener('resize', updateDpad);
})();
</script>
</body>
</html>
